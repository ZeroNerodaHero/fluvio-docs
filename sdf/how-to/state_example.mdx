---
title: "State Example"
description: "State Example"
sidebar_position: 1
---

import CodeBlock from '@theme/CodeBlock';
import StateExample from '!!raw-loader!../_embeds/dataflows/state-example.yaml';

This tutorial is a continuation to the [tumbling how to][tumbling_window]. Unlike the tumbling window, we will write a dataflow that does not have its data expire. We will continue to use states in this example to write a simple dataflow that counts the number of entries sent to a topic. The following [page][states] contains an indepth explanation about states.

## Prerequisites

This guide uses `local` Fluvio cluster. If you need to install it, please follow the instructions at [here][installation].

## Dataflow

### Overview
We will first define a service that contains a state and then a second service that references the state of the first service. Both services will take a sink from the target topic, but only the second service will produce messages to the final topic.

<img src="/img/sdf/how_to_images/state_example.png" alt="Visual of defined dataflow"  style={{ display: 'block', margin: '0 auto', }} width="700" />

### Service A
The purpose of the this service is to read and process data from the sink topic. In this service we will define the state as well as the state logic.

```YAML
count-service:
  sources:
    - type: topic
      id: sentences
  states:
    (...)
  partition:
    assign-key:
      (...)
    update-state:
      (...)
```

#### 1. State definition
For our example, we defined a simple key-value pair. 
```YAML
states:
  counter: 
    type: keyed-state
    properties:
      key: 
        type: string
      value:
        type: u32  
```
#### 2. Assign key
In our state, we have to map inputs to a key in our state. But for our example, our mapping function is trivial. All inputs are mapped to the same output. In most other cases, you can modify the mapping to take on more complicated logic.
```YAML
assign-key:
  run: |
    fn map_count(input: String) -> Result<String> {
      Ok("counter".to_string())
    }
```
#### 3. Updating State
The following part of the dataflow defines how the value of the mapped function is updated. In our case, all we want to do is increment the counter by 1. Because the way we assigned our key, all inputs will increment the same key.
```YAML
run: |
  fn add_count(input: String) -> Result<()> {
    counter().increment(1);
    Ok(())
  }
```

### Service B
The second service serves as a way to read from the state. It will not update the state.

```YAML
map-service:
  sources:
    - type: topic
      id: sentences
  states:
    counter:
      from: count-service.counter
  transforms:
    (...)
  sinks:
    - type: topic
      id: count-input
```

#### 1. Reference the state from service A

We need to reference the state defined in service A. In general it would be `serviceA.state-name`. Now we can reference the state via `state_name()` in our code. There is some special naming conventions to be careful about.
```YAML
states:
  counter:
    from: count-service.counter
```

#### 2. Defining the logic
Our logic for this example is really simple. We will produce messages to the sink. We want our message to contain the total number of messages our service has seen. 
```YAML
transforms:
  - operator: map 
    run: |
      fn new_input(_input: String) -> Result<String> {
        let cc = counter().clone();
        if cc.len() == 0 { return Ok("0".to_string()); }
        return Ok(format!("{}",cc[0].1));
      }
```
As we can see here, the `counter()` references the state defined in service A. For `keyed-state`, the `counter()` returns a vector of tuple of `(key,state)` values. In our case, we only have one key. This function acts like the `flush` in the tumbling window page without actually flushing out the whole state. See the [flush in the window page][window].  

## Running the Example

Copy and paste following config and save it as `dataflow.yaml`.

<CodeBlock language="yaml">{StateExample}</CodeBlock>

To run example:
```bash copy="cmd"
$ sdf run --ephemeral
```

### Produce data
You can produce data to the `sentence` topic via
```bash copy="cmd"
$ echo 'hello' | fluvio produce sentences
```
It does not matter the input as the dataflow only counts entries.

### Consume data
You can consume the topic `count-input`
```bash copy="cmd"
$ fluvio consume count-input -Bd
0
1
2
4
```
The following out is consumed after running the produce command four times. Sometimes the entries will print out the same number or skip. Both services are running together and competing, so there will be some nondeterminism.

## Cleanup

Exit `sdf` terminal and clean-up. The `--force` flag removes the topics:

```bash copy="cmd"
$ sdf clean --force
```


## Conclusion

We just implemented tumbling windows. Windows can be applied to applications needing aggregated data over a specified time window.

[installation]: /docs/fluvio/quickstart#install-fluvio
[tumbling_window]: /sdf/how-to/tumbling_window
[window]: /sdf/how-to/tumbling_window#5-flush-the-window
[states]: /sdf/concepts/state